<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Speech Therapy Game</title>

  <!-- Core framework styles -->
  <link rel="stylesheet" href="../../core/styles.css">

  <!-- Optional game-specific style overrides -->
  <style>
    #choose-screen {
      position: fixed; inset: 0; z-index: 100;
      background: linear-gradient(180deg, #87CEEB 0%, #98D8C8 100%);
      display: flex; flex-direction: column; align-items: center; justify-content: flex-start;
      padding: 1.5rem; overflow-y: auto;
    }
    #choose-screen.hidden { display: none; }
    #choose-screen h2 { font-size: 1.35rem; color: #333; margin-bottom: 1rem; text-align: center; }
    .word-set-list { display: flex; flex-direction: column; gap: 0.75rem; max-width: 520px; width: 100%; margin: 0 auto; }
    .word-set-btn {
      background: #fff; border: 3px solid var(--secondary-color, #FF9800);
      border-radius: 12px; padding: 1rem 1.25rem; font-size: 1rem; color: #333;
      text-align: left; cursor: pointer; box-shadow: 0 2px 8px rgba(0,0,0,0.08);
      transition: transform 0.15s, box-shadow 0.15s;
    }
    .word-set-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.12); }
  </style>
</head>
<body>
  <div id="game-container">
    <!-- Choose word set (shown first when wordSets exist) -->
    <div id="choose-screen">
      <h2>Choose which word pairs to practice</h2>
      <div id="word-set-list" class="word-set-list"></div>
    </div>
    <!-- Full-screen map (always visible once game starts) -->
    <section class="map-section fullscreen">
      <div id="game-map"></div>
    </section>

    <!-- Challenge modal (pops up when needed) -->
    <div id="challenge-modal" class="modal challenge-modal hidden">
      <div class="modal-content challenge-content">
        <h2 id="challenge-prompt">Choose the correct word:</h2>
        <div id="word-pairs" class="pair-container">
          <!-- Dynamically populated by UI class -->
        </div>
      </div>
    </div>

    <!-- Victory modal (hidden by default) -->
    <div id="victory-modal" class="modal victory-modal hidden">
      <div class="modal-content">
        <h1>Victory!</h1>
        <div id="victory-gif-container">
          <img id="victory-gif" src="" alt="Celebration!" />
        </div>
        <p id="victory-message"></p>
        <button id="play-again">Play Again</button>
      </div>
    </div>
  </div>

  <!-- Core framework scripts -->
  <script src="../../core/engine.js"></script>
  <script src="../../core/ui.js"></script>
  <script src="../../core/animator.js"></script>
  <script src="../../core/audio.js"></script>

  <!-- Embedded config (fallback for file:// protocol) -->
  <script type="application/json" id="game-config">
  {"title":"Candy Mountain","description":"Practice with K vs. T","targetSound":"k","contrastSound":"t","protagonist":{"character":"explorer","images":{"idle":"assets/protagonist/idle.png","walking":"assets/protagonist/walking.png","celebrating":"assets/protagonist/celebrating.png"}},"map":{"theme":"candy mountain","pathstyle":"mountainous","backgroundImage":"../../assets/maps/candymountain.png"},"challenges":[{"id":1,"correctWord":"cab","correctSound":"k","pairs":[{"word":"cab","sound":"k","image":"assets/pairs/cab.jpg","alt":"taxi cab clipart"},{"word":"tab","sound":"t","image":"assets/pairs/tab.png","alt":"soda can tab clipart"}]},{"id":2,"correctWord":"car","correctSound":"k","pairs":[{"word":"car","sound":"k","image":"assets/pairs/car.jpg","alt":"car clipart"},{"word":"tar","sound":"t","image":"assets/pairs/tar.jpg","alt":"tar clipart"}]}],"victory":{"message":"Congratulations! You've mastered these sounds!","music":"../../assets/audio/victory.mp3","gif":"https://media4.giphy.com/media/v1.Y2lkPTc5MGI3NjExOTlsenFrbmVwYjBrdHR5d2pyN3Azbzl3MXgxcHk3ZTFqZjVjcmppZSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/d3RObx3BG7pTASeyZ0/giphy.gif"}}
  </script>

  <!-- Game initialization -->
  <script>
    // Initialize game components
    const engine = new GameEngine('./config.json');
    const ui = new GameUI(document.getElementById('game-container'));
    const animator = new PathAnimator(ui);
    const audio = new AudioManager();

    // Game state
    let isProcessing = false;

    const NUM_CHALLENGES = 12;
    const WORD_SET_FOLDERS = {
      'candy-default': 'T:K Minimal Pairs - Initial',
      'tk-k1': 'T:K Minimal Pairs - Initial', 'tk-t1': 'T:K Minimal Pairs - Initial',
      'tk-k2': 'T:K Minimal Pairs - Final', 'tk-t2': 'T:K Minimal Pairs - Final',
      'dg-d1': 'D:G Minimal Pairs - Initial', 'dg-g1': 'D:G Minimal Pairs - Initial',
      'dg-d2': 'D:G Miminal Pairs - Final', 'dg-g2': 'D:G Miminal Pairs - Final',
      'vb-b1': 'V:B Minimal Pairs - Initial', 'vb-v1': 'V:B Minimal Pairs - Initial',
      'vb-b2': 'V:B Minimal Pairs - Final', 'vb-v2': 'V:B Minimal Pairs - Final'
    };

    function wordImagesRoot() {
      const path = window.location.pathname.replace(/\/games\/[^/]+(\/.*)?$/, '');
      return window.location.origin + (path.endsWith('/') ? path : path + '/');
    }

    function pairImagePath(word, setId) {
      const file = (word === 'v' || word === 'V') ? 'v' : (word === 'Ed') ? 'Ed' : word.toLowerCase();
      const filename = file + '.png';
      const folder = setId && WORD_SET_FOLDERS[setId];
      if (folder) {
        const encodedFolder = encodeURIComponent(folder).replace(/%2F/g, '/');
        try {
          return new URL('word-images/' + encodedFolder + '/' + filename, wordImagesRoot()).href;
        } catch (e) {
          return '../../word-images/' + encodedFolder + '/' + filename;
        }
      }
      return 'assets/pairs/' + filename;
    }

    function buildChallengesFromWordSet(set) {
      const pairs = set.pairs || [];
      const targetSound = set.targetSound || 'k';
      const contrastSound = set.contrastSound || 't';
      const setId = set.id;
      const challenges = [];
      for (let i = 0; i < NUM_CHALLENGES; i++) {
        const pair = pairs[i % pairs.length];
        const targetWord = pair[0];
        const contrastWord = pair[1];
        challenges.push({
          id: i + 1,
          correctWord: targetWord,
          correctSound: targetSound,
          pairs: [
            { word: targetWord, sound: targetSound, image: pairImagePath(targetWord, setId), alt: targetWord },
            { word: contrastWord, sound: contrastSound, image: pairImagePath(contrastWord, setId), alt: contrastWord }
          ]
        });
      }
      return challenges;
    }

    function showChooseScreen() {
      const list = document.getElementById('word-set-list');
      const chooseScreen = document.getElementById('choose-screen');
      if (!list || !chooseScreen) return;
      const sets = engine.config.wordSets || [];
      list.innerHTML = '';
      sets.forEach((set) => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'word-set-btn';
        btn.textContent = set.label;
        btn.addEventListener('click', () => {
          engine.config.challenges = buildChallengesFromWordSet(set);
          chooseScreen.classList.add('hidden');
          renderGame();
        });
        list.appendChild(btn);
      });
    }

    // Initialize and start game
    async function initGame() {
      try {
        // Load game configuration
        await engine.loadConfig();

        // Set page title from config
        document.title = engine.config.title || 'Speech Therapy Game';

        // Initialize UI
        ui.init();

        // Initialize audio if available
        if (engine.config.victory && engine.config.victory.music) {
          audio.init(engine.config.victory.music);
        }

        // Set up event handlers (before any screen flow)
        setupEventHandlers();

        // Unlock audio on first user interaction (iOS requirement)
        document.addEventListener('click', () => {
          audio.unlockAudio();
        }, { once: true });

        const wordSets = engine.config.wordSets || [];
        if (wordSets.length > 0) {
          showChooseScreen();
          return;
        }

        // No word sets: start with config challenges
        renderGame();

      } catch (error) {
        console.error('Failed to initialize game:', error);
        alert('Failed to load game. Please check the console for details.');
      }
    }

    // Render current game state
    async function renderGame(showChallengeDelay = 1500) {
      const challenge = engine.getCurrentChallenge();

      if (challenge) {
        // Render map first
        const totalChallenges = engine.config.challenges.length;
        const mapConfig = {
          ...(engine.config.map || {}),
          protagonist: engine.config.protagonist
        };
        ui.renderMap(totalChallenges, engine.currentPosition, mapConfig);

        // Initialize animator
        animator.init();

        // Wait before showing challenge (let user see the map/position)
        await new Promise(resolve => setTimeout(resolve, showChallengeDelay));

        // Now render and show the challenge
        ui.renderChallenge(challenge, engine.config);
      } else if (engine.isVictory()) {
        // Show victory screen
        handleVictory();
      }
    }

    // Set up event handlers
    function setupEventHandlers() {
      // Handle answer selection
      ui.onAnswer(async (choiceIndex) => {
        if (isProcessing) return;
        isProcessing = true;

        // Submit answer
        const result = await engine.submitAnswer(choiceIndex);

        // Show feedback
        ui.showFeedback(result.correct);

        // Wait for feedback animation
        await new Promise(resolve => setTimeout(resolve, 800));

        // Hide challenge modal to show map animation
        ui.hideChallengeModal();

        // Wait for modal to fully close
        await new Promise(resolve => setTimeout(resolve, 400));

        // Animate protagonist movement
        if (result.correct && engine.currentPosition > 0) {
          animator.playForwardFeedback();
        } else if (!result.correct) {
          animator.playBackwardFeedback();
        }

        // Wait for movement animation to complete (800ms is the default duration)
        await animator.moveToPosition(result.newPosition, 800);

        // Wait a moment at new position before next challenge
        await new Promise(resolve => setTimeout(resolve, 800));

        // Check for victory
        if (engine.isVictory()) {
          await handleVictory();
        } else {
          // Render next challenge with shorter delay (already waited above)
          await renderGame(1000);
        }

        isProcessing = false;
      });

      // Handle play again
      ui.onPlayAgain(() => {
        engine.reset();
        ui.hideVictory();
        if (engine.config.wordSets && engine.config.wordSets.length > 0) {
          document.getElementById('choose-screen').classList.remove('hidden');
          showChooseScreen();
        } else {
          renderGame();
        }
      });
    }

    // Handle victory
    async function handleVictory() {
      // Celebrate animation
      await animator.celebrate();

      // Show victory screen (fetch GIF)
      await ui.showVictory(engine.config);

      // Play victory music
      await audio.playVictory();
    }

    // Start the game
    initGame();
  </script>
</body>
</html>
